# Report of The Fundamentals of Digital Logic and Processors First Project: Assembly Language

## Part 1: Basic Exercise

### Exercise 1-1: System Call (`exp1_1.asm`)

There are 9 `systemcall`s in the file `exp1_1.asm`:

1. Open file: `$v0` = 13, `$a0` = address of the file name "a.in", `$a1` = 0 (read only)
2. Read file: `$v0` = 14, `$a0` = file descriptor, `$a1` = address of the buffer, `$a2` = buffer size
3. Close file: `$v0` = 16, `$a0` = file descriptor
4. Open file: `$v0` = 13, `$a0` = address of the file name "a.out", `$a1` = 1 (write only)
5. Write file: `$v0` = 15, `$a0` = file descriptor, `$a1` = address of the buffer, `$a2` = buffer size
6. Close file: `$v0` = 16, `$a0` = file descriptor
7. Read integer: `$v0` = 5
8. Print integer: `$v0` = 1, `$a0` = integer to print
9. Exit: `$v0` = 10

The `buffer` is defined in the `.data` section instead of using the heap.

### Exercise 1-2: Loop and Branch (`exp1_2.asm`)

In `exp1_2.asm`, `temp` is stored in `$t0`, `i` is stored in `$t1`, `j` is stored in `$t2`.

After inputting `i` and `j`, the program judges whether `j < 0`. If not, the program branches to the label `ELSE`, which skips `j = -j`.

In the loop, the program judges whether `temp >= j` and first. If so, the program branches to the label `END`, which skips the loop. Otherwise, the program lets `i += 1` and `++temp`, then jumps back to the label `LOOP`.

### Exercise 1-3: Array and Pointer (`exp1_3.asm`)

The program first reads the length `n` of the array, and then left shifts the length by 2 to get the size of the array. The program then uses `syscall` 9 to allocate memory for the array.

Then, yhe program enters a loop to read the elements of the array. It first adds address of array `a` and `i * 4` to get the address of the `i`-th element, and then reads the element into the address using `syscall` 5.

After reading all elements, the program enters another loop to operate the elements. The program calculates the address of `a[i]` into `$t0`, the address of `a[n - i - 1]` into `$t1`, the value of `a[i]` into `$t2`, and the value of `a[n - i - 1]` into `$t3`. The program then swaps the values of `a[i]` and `a[n - i - 1]`.

Finally, the program prints the elements of the array.

### Exercise 1-4: Function Call (`exp1_4.asm`)

The program first reads an integer `n`. Then it enters `Hanoi` function. In the function, the program first minus `$sp` by 4 to allocate space for the return address, and then stores the return address into the stack. The program then judges whether `n == 1`. If so, the program prints the move of the disk. Otherwise, the program calls `Hanoi` recursively to move the disks. When the function returns, the program restores the stack and returns.

## Part 2: Practical Application

### Direct Insertion Sort

In `.data` section, the program defines `buffer` as a 4004-byte space, `compare_count` as a word with initial value 0, `infile` as a string "a.in", and `outfile` as a string "a.out".

The program first reads the file, then puts `buffer[1]` in `$a0` and `N` in `$a1` and calls `insertion_sort`.

The function `insertion_sort` stores `v[]` in `$s1`, `N` in `$s2`, and enters a loop whose `i` stored in `$s0`. In the loop, `v[]` is moved to `$a0` and `i` is moved to `$a1`, and `search` is called. After that, the return value `place` is stored in `$v0`. Then `v[]` is moved to `$a0`, `place` is moved to `$a1`, `i` is moved to `$a2` and `insert` is called. Finally, `i` is incremented and the loop continues.

The function `search` stores `compare_count` in `$t0`, `v[n]` in `$t1`, `i` in `$t2` which has initial value `n - 1`. Then the function enters the loop. In the loop, `v[i]` is stored in `$t3`. `compare_count` is incremented and `i` is decremented. The loop continues until `v[i] >= v[n]`. Then the function returns `i + 1`.

The function `insert` stores `v[n]` in `$t0`, `i` in `$t1` which has initial value `n - 1`. Then the function enters the loop. In the loop, the address of `v[i]` is moved to `$t2` while the value is stored in `$t3`. `v[i]` is saved to `v[i + 1]`. `i` is decremented and the loop continues until `i < place`. Finally, `v[n]` is stored to `v[place]`.

In the final result, `compare_count` is 103, which is the same as the expected result generated by the C++ program.

Result: 

```
67 00 00 00 4E 04 00 00 FF 09 00 00 2B 0C 00 00
8D 12 00 00 44 2F 00 00 48 37 00 00 18 39 00 00
F2 3A 00 00 56 3C 00 00 12 41 00 00 A8 41 00 00
55 49 00 00 D9 8E 00 00 99 98 00 00 DA AC 00 00
83 B7 00 00 99 C3 00 00 B4 D4 00 00 C9 DA 00 00
E3 DB 00 00
```

### Binary Insertion Sort

Binary insertion sort is similar to direct insertion sort, the only differences are `insertion_sort` / `binary_insertion_sort` and `search` / `binary_search`.

The function `binary_insertion_sort` is similar to `insertion_sort`, but it calls `binary_search` instead of `search`. When doing so, `v[]` is moved to `$a0`, `left` is moved to `$a1` which equals 0, `right` is moved to `$a2` which equals `i - 1`, and `n` is moved to `$a3` which equals `i`.

The function `binary_search` first judges if `left > right`. If so, the function returns `left`. Otherwise, the function adds `$a1`(`left`) and `$a2`(`right`) into `$s0`, then right shifts `$s0` by 1 which gets `(left + right) / 2`. The function then loads, increments and saves `compare_count`. The function then stores `v[mid]` in `$t0` and `v[n]` in `$t1`, and judges whether `v[mid] <= v[n]`. If so, the function sets `left = mid + 1`, otherwise `right = mid - 1`. The function then jumps back to the beginning of the loop.

In the final result, `compare_count` is 62, which is the same as the expected result generated by the C++ program.

Result:

```
3E 00 00 00 4E 04 00 00 FF 09 00 00 2B 0C 00 00
8D 12 00 00 44 2F 00 00 48 37 00 00 18 39 00 00
F2 3A 00 00 56 3C 00 00 12 41 00 00 A8 41 00 00
55 49 00 00 D9 8E 00 00 99 98 00 00 DA AC 00 00
83 B7 00 00 99 C3 00 00 B4 D4 00 00 C9 DA 00 00
E3 DB 00 00
```

### Merge Sort (Linked List)

In `.data` section, the program defines `buffer` as a 4004-byte space, `compare_count` as a word with initial value 0, `head` as a 8-byte space, `infile` as a string "a.in", and `outfile` as a string "a.out".

In the function `main`, the program reads the file, enters the loop to create the linked list. In the loop, it uses `syscall` 9 to allocate memory for the node, and stores the return value in `$t1`, `idx` in `$t2`, `buffer[idx]` in `$t3`. Then it stores `head[1]` in `$a0` and calls `msort`. Then it prints the sorted linked list in the file.

In the function `msort`, `head[1]` is stored in `$t0`, `stride_1_pointer` is stored in `$t1`, `stride_2_pointer` is stored in `$t2`. `$t3` is used as a temporary register. `head` is stored in `$s0`, `stride_2_pointer` after the loop is stored in `$s1`, `l_head` is stored in `$s2`, `r_head` is stored in `$s3`. Then `l_head` and `r_head` are moved to `$a0` and `$a1` respectively, and `merge` is called.

In the function `merge`, `l_head` is stored in `$s0`, `r_head` is stored in `$s1`. `$t0` is `head`, `$t1` is `p_left`, `$t2` is `p_right`, `$t4` is `p_right_temp`, `$t5` is `temp_right_pointer_next`. After merge, `rv` is stored in `$v0` and returned.

In the final result, `compare_count` is 76, which is the same as the expected result generated by the C++ program.

Result:

```
4C 00 00 00 4E 04 00 00 FF 09 00 00 2B 0C 00 00
8D 12 00 00 44 2F 00 00 48 37 00 00 18 39 00 00
F2 3A 00 00 56 3C 00 00 12 41 00 00 A8 41 00 00
55 49 00 00 D9 8E 00 00 99 98 00 00 DA AC 00 00
83 B7 00 00 99 C3 00 00 B4 D4 00 00 C9 DA 00 00
E3 DB 00 00
```